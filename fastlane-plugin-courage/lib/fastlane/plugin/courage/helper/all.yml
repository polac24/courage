
- mutation: 
    name: "Invert Array"
    required:
      return: 
        type: "Array"
        generic: 
          variable: "type"
    actions:
      before_function_return: "\ \ %1 = alloc_stack $Array<@type>                // users: %2, %5, %4\n
\ store #0 to %1 : $*Array<@type>              // id: %2\n
\ //function_ref Sequence.reversed()\n
\ %3 = function_ref @$Ss8SequencePsE8reversedSay7ElementQzGyF : $@convention(method) <τ_0_0 where τ_0_0 : Sequence> (@in_guaranteed τ_0_0) -> @owned Array<τ_0_0.Element> // user: %4\n
\ %4 = apply %3<[@type]>(%1) : $@convention(method) <τ_0_0 where τ_0_0 : Sequence> (@in_guaranteed τ_0_0) -> @owned Array<τ_0_0.Element> // user: %8\n
\ dealloc_stack %1 : $*Array<@type>             // id: %5\n
\ return %4 : $Array<@type>                     // id: %8\n"
      dependencies:
        - file: 
          file: "sil/revesed_array.sil"


- mutation: 
    name: "Empty Array"
    required:
      return: 
        type: "Array"
        generic: 
          variable: "type"
    actions:
      before_function_return: "\ \ %2 = metatype $@thin Array<@type>.Type           // user: %12\n
\ %3 = integer_literal $Builtin.Word, 0           // user: %5\n
\ // function_ref _allocateUninitializedArray<A>(_:)\n
\ %4 = function_ref @$Ss27_allocateUninitializedArrayySayxG_BptBwlF : $@convention(thin) <τ_0_0> (Builtin.Word) -> (@owned Array<τ_0_0>, Builtin.RawPointer) // user: %5\n
\ %5 = apply %4<@type>(%3) : $@convention(thin) <τ_0_0> (Builtin.Word) -> (@owned Array<τ_0_0>, Builtin.RawPointer) // users: %9, %6, %8\n
\ %6 = tuple_extract %5 : $(Array<@type>, Builtin.RawPointer), 0 // users: %12, %7\n
\ retain_value %6 : $Array<@type>                  // id: %7\n
\ %8 = tuple_extract %5 : $(Array<@type>, Builtin.RawPointer), 1 // user: %10\n
\ release_value %5 : $(Array<@type>, Builtin.RawPointer) // id: %9\n
\ %10 = pointer_to_address %8 : $Builtin.RawPointer to [strict] $*@type\n
\ // function_ref Array.init(arrayLiteral:)\n
\ %11 = function_ref @$SSa12arrayLiteralSayxGxd_tcfC : $@convention(method) <τ_0_0> (@owned Array<τ_0_0>, @thin Array<τ_0_0>.Type) -> @owned Array<τ_0_0> // user: %12\n
\ %12 = apply %11<@type>(%6, %2) : $@convention(method) <τ_0_0> (@owned Array<τ_0_0>, @thin Array<τ_0_0>.Type) -> @owned Array<τ_0_0> // user: %13\n
\ return %12 : $Array<@type>                       // id: %13\n"
      dependencies:
        - file: 
          file: "sil/empty_array.sil"

- mutation: 
    name: "Return nil"
    required:
      return:
        type: "Optional"
        generic: 
          variable: "type"
    actions:
      before_function_return: "\ \ %1 = alloc_stack $Optional<@type>              // users: %2, %3, %4\n
\ inject_enum_addr %1 : $*Optional<@type>, #Optional.none!enumelt // id: %2\n
\ %3 = tuple ()\n
\ %4 = load %1 : $*Optional<@type>               // user: %6\n
\ dealloc_stack %1 : $*Optional<@type>           // id: %5\n
\ return %4 : $Optional<@type>                   // id: %6\n"


- mutation: 
    name: "No operation"
    required:
      return: "()"
    actions:
      before_function_return: "\ \ %1 = tuple ()                                   // user: %2\n
\ return %1 : $()                                 // id: %2"

